{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"nf-test Simple test framework for Nextflow pipelines Getting Started Installation Source","title":"Home"},{"location":"#nf-test","text":"Simple test framework for Nextflow pipelines Getting Started Installation Source","title":"nf-test"},{"location":"assertions/","text":"Assertions process and workflow objects Examples: // process status assert process . success assert process . failed assert process . exitStatus == 0 // process error message assert process . errorReport . contains ( \"....\" ) // workflow status assert workflow . success assert workflow . failed assert workflow . exitStatus == 0 // workflow error message assert workflow . errorReport . contains ( \"....\" ) // trace //returns a list containing succeeded tasks assert workflow . trace . succeeded (). size () == 3 //returns a list containing failed tasks assert workflow . trace . failed (). size () == 0 //returns a list containing all tasks assert workflow . trace . tasks (). size () == 3 Use regular expressions The operator ==~ can be used to check if a string matches a regular expression: assert \"/my/full/path/to/process/dir/example.vcf.pgen\" ==~ \".*/example.vcf.pgen\" Use with This assertions... assert process . out . imputed_plink2 assert process . out . imputed_plink2 . size () == 1 assert process . out . imputed_plink2 . get ( 0 ). get ( 0 ) == \"example.vcf\" assert process . out . imputed_plink2 . get ( 0 ). get ( 1 ) ==~ \".*/example.vcf.pgen\" assert process . out . imputed_plink2 . get ( 0 ). get ( 2 ) ==~ \".*/example.vcf.psam\" assert process . out . imputed_plink2 . get ( 0 ). get ( 3 ) ==~ \".*/example.vcf.pvar\" ... can be written by using with(){} to improve readability: assert process . out . imputed_plink2 with ( process . out . imputed_plink2 ) { assert size () == 1 with ( get ( 0 )) { assert get ( 0 ) == \"example.vcf\" assert get ( 1 ) ==~ \".*/example.vcf.pgen\" assert get ( 2 ) ==~ \".*/example.vcf.psam\" assert get ( 3 ) ==~ \".*/example.vcf.pvar\" } } Use file hash nf-test extends path by a md5 property that can be used to compare the file content with an expected checksum: assert path ( process . out . out_ch . get ( 0 )). md5 == \"64debea5017a035ddc67c0b51fa84b16\"","title":"Assertions"},{"location":"assertions/#assertions","text":"","title":"Assertions"},{"location":"assertions/#process-and-workflow-objects","text":"Examples: // process status assert process . success assert process . failed assert process . exitStatus == 0 // process error message assert process . errorReport . contains ( \"....\" ) // workflow status assert workflow . success assert workflow . failed assert workflow . exitStatus == 0 // workflow error message assert workflow . errorReport . contains ( \"....\" ) // trace //returns a list containing succeeded tasks assert workflow . trace . succeeded (). size () == 3 //returns a list containing failed tasks assert workflow . trace . failed (). size () == 0 //returns a list containing all tasks assert workflow . trace . tasks (). size () == 3","title":"process and workflow objects"},{"location":"assertions/#use-regular-expressions","text":"The operator ==~ can be used to check if a string matches a regular expression: assert \"/my/full/path/to/process/dir/example.vcf.pgen\" ==~ \".*/example.vcf.pgen\"","title":"Use regular expressions"},{"location":"assertions/#use-with","text":"This assertions... assert process . out . imputed_plink2 assert process . out . imputed_plink2 . size () == 1 assert process . out . imputed_plink2 . get ( 0 ). get ( 0 ) == \"example.vcf\" assert process . out . imputed_plink2 . get ( 0 ). get ( 1 ) ==~ \".*/example.vcf.pgen\" assert process . out . imputed_plink2 . get ( 0 ). get ( 2 ) ==~ \".*/example.vcf.psam\" assert process . out . imputed_plink2 . get ( 0 ). get ( 3 ) ==~ \".*/example.vcf.pvar\" ... can be written by using with(){} to improve readability: assert process . out . imputed_plink2 with ( process . out . imputed_plink2 ) { assert size () == 1 with ( get ( 0 )) { assert get ( 0 ) == \"example.vcf\" assert get ( 1 ) ==~ \".*/example.vcf.pgen\" assert get ( 2 ) ==~ \".*/example.vcf.psam\" assert get ( 3 ) ==~ \".*/example.vcf.pvar\" } }","title":"Use with"},{"location":"assertions/#use-file-hash","text":"nf-test extends path by a md5 property that can be used to compare the file content with an expected checksum: assert path ( process . out . out_ch . get ( 0 )). md5 == \"64debea5017a035ddc67c0b51fa84b16\"","title":"Use file hash"},{"location":"configuration/","text":"Configuration Setup test profile To run your test using a specific Netxflow profile, you can use the --profile argument on the comand line or define a default profile in nf-test.config nf-test.config This config file contains settings for nftest. config { // location where nftest should save test scripts testsDir \"tests\" // location of a nextflow.config file specific for executing tets configFile \"tests/nextflow.config\" // run all test with docker profile profile \"docker\" } tests/nextflow.config This nextflow.config file is used to execute tests. This is a good place to set default params for all your tests. Example number of threads: params { // run all tests with 1 threads threads = 1 }","title":"Configuration"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/#setup-test-profile","text":"To run your test using a specific Netxflow profile, you can use the --profile argument on the comand line or define a default profile in nf-test.config","title":"Setup test profile"},{"location":"configuration/#nf-testconfig","text":"This config file contains settings for nftest. config { // location where nftest should save test scripts testsDir \"tests\" // location of a nextflow.config file specific for executing tets configFile \"tests/nextflow.config\" // run all test with docker profile profile \"docker\" }","title":"nf-test.config"},{"location":"configuration/#testsnextflowconfig","text":"This nextflow.config file is used to execute tests. This is a good place to set default params for all your tests. Example number of threads: params { // run all tests with 1 threads threads = 1 }","title":"tests/nextflow.config"},{"location":"getting-started/","text":"Getting started For this example we use the gwas-regenie pipeline. Open the terminal and clone the pipeline: # clone nextflow pipeline git clone https://github.com/genepi/gwas-regenie # enter project directory cd gwas-regenie We use the imputed_to_plink2.nf process to create a testcase from scratch. This process takes a vcf file as input and converts it into the Plink2 format. Init Before we start creating our testcases, we use the init command to setup nf-test: $ nf-test init The init command creates the following files in the root directory of the pipeline: nf-test.config and tests/nextflow.config . It also creates a folder tests which is the home of your testcode. In the configuration section you can learn more about this files. Create your first test The generate command helps you to create skeleton test code for a Nextflow process or the whole workflow. Here we generate a testcase for the process imputed_to_plink2.nf : $ nf-test generate process modules/local/imputed_to_plink2.nf This command creates a new file tests/modules/local/imputed_to_plink2.nf.test with the following content: nextflow_process { name \"Test Process IMPUTED_TO_PLINK2\" script \"modules/local/imputed_to_plink2.nf\" process \"IMPUTED_TO_PLINK2\" test ( \"Should run without failures\" ) { when { params { // define parameters here. Example: // outdir = \"tests/results\" } process { \"\"\" // define inputs of the process here. Example: // input[0] = file(\"test-file.txt\") \"\"\" } } then { assert process . success process . out . with { // Make assertions about the content and elements of output channels here. Example: // assert outdir != null } } } } The generate command filled automatically the name, script and process of our testcase as well as created a skeleton for your first test method. Typically you create one file per process and use different test methods to describe the expected behaviour of the process. A test has a name, a when and a then closure. The when block describes the input parameters of the workflow or the process. nf-test executes the process with exactly this parameters and parses the content of the output channels. Then, it evaluates the assertions defined in the then block to check if content of the output channels matches your expectations. The when block The when block describes the input of our process and/or the Nextflow params . The params block is optional and is a simple map that can be used to override Nextflows input params . The process block is a multiline string and you can use the input array to set the different inputs arguments of the process. In our example, we have only one input that expects a file. Let us update the process block by setting the first element of the input array to the path of a small VCF file: when { params { outdir = \"output\" } process { \"\"\" // Use example.vc.gz as first input for our process input[0] = file(\"tests/input/example.vcf.gz\") \"\"\" } } Everything that is defined in the process block is later executed in the Nextflow script that is created automatically to test your process. Therefore, you can use every Nextflow specific functions and commands to define the values of the input array (e.g. Channels, files, ...). The then block The then block describes the expected output channels of the process when we execute it with the input parameters from the when block. The then block typically contains mainly assertions to check for example the size and the content of an output channel. However, this block accepts every Groovy script so you can import also third party libraries to define very specific assertions (e.g. a VCF-File Reader can be used to check number of variants). nf-test automatically loads all output channels of the process and all their items into a map named process.out . You can then use this map to formulate your assertions. For example, in the imputed_to_plink2 process we expect to get an tuple that contains the filename, the pgen file, the psam file and the pvar file. Let us update the then section with some assertions that describe our expectations: then { // Checks if process runs without failures assert process . success //Checks if a chanell imputed_pink2 was created, has 1 element assert process . out . imputed_plink2 assert process . out . imputed_plink2 . size () == 1 //Checks if first tuple contains the expected content assert process . out . imputed_plink2 . get ( 0 ). get ( 0 ) == \"example.vcf\" assert process . out . imputed_plink2 . get ( 0 ). get ( 1 ) ==~ \".*/example.vcf.pgen\" 1 \ufe0f\u20e3 assert process . out . imputed_plink2 . get ( 0 ). get ( 2 ) ==~ \".*/example.vcf.psam\" assert process . out . imputed_plink2 . get ( 0 ). get ( 3 ) ==~ \".*/example.vcf.pvar\" //Checks if psam file contains 500 samples and 1 header line def psam = process . out . imputed_plink2 . get ( 0 ). get ( 2 ) assert file ( psam ). readLines (). size () == 501 2 \ufe0f\u20e3 } 1\ufe0f\u20e3 we use a regular expression matching to check the filename, because the channels contains always the full path to an output file. 2\ufe0f\u20e3 since we get the full path to a file, we can open it and compare the number of lines. We can also calculate a hash of the file and compare it with an expected one. See Assertions for some examples and inspiration. The items of a channel are always sorted by nf-test. This provides a deterministic order inside the channel and enables you to write reproducible tests. Your first test specification You can update the name of the test method to something that gives us later a good description of our specification. When we put everything together, we get the following full working test specification: nextflow_process { name \"Test Process IMPUTED_TO_PLINK2\" script \"modules/local/imputed_to_plink2.nf\" process \"IMPUTED_TO_PLINK2\" test ( \"Should create a pgen, psam and pvar file with 500 samples\" ) { when { process { \"\"\" input[0] = file(\"tests/input/example.vcf.gz\") \"\"\" } } then { assert process . success assert process . out . imputed_plink2 assert process . out . imputed_plink2 . size () == 1 assert process . out . imputed_plink2 . get ( 0 ). get ( 0 ) == \"example.vcf\" assert process . out . imputed_plink2 . get ( 0 ). get ( 1 ) ==~ \".*/example.vcf.pgen\" assert process . out . imputed_plink2 . get ( 0 ). get ( 2 ) ==~ \".*/example.vcf.psam\" assert process . out . imputed_plink2 . get ( 0 ). get ( 3 ) ==~ \".*/example.vcf.pvar\" def psam = process . out . imputed_plink2 . get ( 0 ). get ( 2 ) assert file ( psam ). readLines (). size () == 501 } } } Run your first test Now, the test command can be used to run your test: $ nf-test test tests/modules/local/imputed_to_plink2.nf.test --profile docker In this case, the docker profile defined in the Nextflow pipeline is used to execute the test. The profile is set using the --profile parameter, but you can also define a default profile in the configuration file . Congratulation! You created you first nf-test specification. What's next? Learn how to write Assertions Learn how to write workflow tests (integration test or e2e) Learn how to config nf-test","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"For this example we use the gwas-regenie pipeline. Open the terminal and clone the pipeline: # clone nextflow pipeline git clone https://github.com/genepi/gwas-regenie # enter project directory cd gwas-regenie We use the imputed_to_plink2.nf process to create a testcase from scratch. This process takes a vcf file as input and converts it into the Plink2 format.","title":"Getting started"},{"location":"getting-started/#init","text":"Before we start creating our testcases, we use the init command to setup nf-test: $ nf-test init The init command creates the following files in the root directory of the pipeline: nf-test.config and tests/nextflow.config . It also creates a folder tests which is the home of your testcode. In the configuration section you can learn more about this files.","title":"Init"},{"location":"getting-started/#create-your-first-test","text":"The generate command helps you to create skeleton test code for a Nextflow process or the whole workflow. Here we generate a testcase for the process imputed_to_plink2.nf : $ nf-test generate process modules/local/imputed_to_plink2.nf This command creates a new file tests/modules/local/imputed_to_plink2.nf.test with the following content: nextflow_process { name \"Test Process IMPUTED_TO_PLINK2\" script \"modules/local/imputed_to_plink2.nf\" process \"IMPUTED_TO_PLINK2\" test ( \"Should run without failures\" ) { when { params { // define parameters here. Example: // outdir = \"tests/results\" } process { \"\"\" // define inputs of the process here. Example: // input[0] = file(\"test-file.txt\") \"\"\" } } then { assert process . success process . out . with { // Make assertions about the content and elements of output channels here. Example: // assert outdir != null } } } } The generate command filled automatically the name, script and process of our testcase as well as created a skeleton for your first test method. Typically you create one file per process and use different test methods to describe the expected behaviour of the process. A test has a name, a when and a then closure. The when block describes the input parameters of the workflow or the process. nf-test executes the process with exactly this parameters and parses the content of the output channels. Then, it evaluates the assertions defined in the then block to check if content of the output channels matches your expectations.","title":"Create your first test"},{"location":"getting-started/#the-when-block","text":"The when block describes the input of our process and/or the Nextflow params . The params block is optional and is a simple map that can be used to override Nextflows input params . The process block is a multiline string and you can use the input array to set the different inputs arguments of the process. In our example, we have only one input that expects a file. Let us update the process block by setting the first element of the input array to the path of a small VCF file: when { params { outdir = \"output\" } process { \"\"\" // Use example.vc.gz as first input for our process input[0] = file(\"tests/input/example.vcf.gz\") \"\"\" } } Everything that is defined in the process block is later executed in the Nextflow script that is created automatically to test your process. Therefore, you can use every Nextflow specific functions and commands to define the values of the input array (e.g. Channels, files, ...).","title":"The when block"},{"location":"getting-started/#the-then-block","text":"The then block describes the expected output channels of the process when we execute it with the input parameters from the when block. The then block typically contains mainly assertions to check for example the size and the content of an output channel. However, this block accepts every Groovy script so you can import also third party libraries to define very specific assertions (e.g. a VCF-File Reader can be used to check number of variants). nf-test automatically loads all output channels of the process and all their items into a map named process.out . You can then use this map to formulate your assertions. For example, in the imputed_to_plink2 process we expect to get an tuple that contains the filename, the pgen file, the psam file and the pvar file. Let us update the then section with some assertions that describe our expectations: then { // Checks if process runs without failures assert process . success //Checks if a chanell imputed_pink2 was created, has 1 element assert process . out . imputed_plink2 assert process . out . imputed_plink2 . size () == 1 //Checks if first tuple contains the expected content assert process . out . imputed_plink2 . get ( 0 ). get ( 0 ) == \"example.vcf\" assert process . out . imputed_plink2 . get ( 0 ). get ( 1 ) ==~ \".*/example.vcf.pgen\" 1 \ufe0f\u20e3 assert process . out . imputed_plink2 . get ( 0 ). get ( 2 ) ==~ \".*/example.vcf.psam\" assert process . out . imputed_plink2 . get ( 0 ). get ( 3 ) ==~ \".*/example.vcf.pvar\" //Checks if psam file contains 500 samples and 1 header line def psam = process . out . imputed_plink2 . get ( 0 ). get ( 2 ) assert file ( psam ). readLines (). size () == 501 2 \ufe0f\u20e3 } 1\ufe0f\u20e3 we use a regular expression matching to check the filename, because the channels contains always the full path to an output file. 2\ufe0f\u20e3 since we get the full path to a file, we can open it and compare the number of lines. We can also calculate a hash of the file and compare it with an expected one. See Assertions for some examples and inspiration. The items of a channel are always sorted by nf-test. This provides a deterministic order inside the channel and enables you to write reproducible tests.","title":"The then block"},{"location":"getting-started/#your-first-test-specification","text":"You can update the name of the test method to something that gives us later a good description of our specification. When we put everything together, we get the following full working test specification: nextflow_process { name \"Test Process IMPUTED_TO_PLINK2\" script \"modules/local/imputed_to_plink2.nf\" process \"IMPUTED_TO_PLINK2\" test ( \"Should create a pgen, psam and pvar file with 500 samples\" ) { when { process { \"\"\" input[0] = file(\"tests/input/example.vcf.gz\") \"\"\" } } then { assert process . success assert process . out . imputed_plink2 assert process . out . imputed_plink2 . size () == 1 assert process . out . imputed_plink2 . get ( 0 ). get ( 0 ) == \"example.vcf\" assert process . out . imputed_plink2 . get ( 0 ). get ( 1 ) ==~ \".*/example.vcf.pgen\" assert process . out . imputed_plink2 . get ( 0 ). get ( 2 ) ==~ \".*/example.vcf.psam\" assert process . out . imputed_plink2 . get ( 0 ). get ( 3 ) ==~ \".*/example.vcf.pvar\" def psam = process . out . imputed_plink2 . get ( 0 ). get ( 2 ) assert file ( psam ). readLines (). size () == 501 } } }","title":"Your first test specification"},{"location":"getting-started/#run-your-first-test","text":"Now, the test command can be used to run your test: $ nf-test test tests/modules/local/imputed_to_plink2.nf.test --profile docker In this case, the docker profile defined in the Nextflow pipeline is used to execute the test. The profile is set using the --profile parameter, but you can also define a default profile in the configuration file . Congratulation! You created you first nf-test specification.","title":"Run your first test"},{"location":"getting-started/#whats-next","text":"Learn how to write Assertions Learn how to write workflow tests (integration test or e2e) Learn how to config nf-test","title":"What's next?"},{"location":"installation/","text":"Installation nf-test has the same requirements as Nextflow and can be used on POSIX compatible systems like Linux or OS X. You can install nf-test using the following command: curl -fsSL https://code.askimed.com/install/nf-test | bash If you don't have curl installed, you could use wget: wget -qO- https://code.askimed.com/install/nf-test | bash It will create the nf-test executable file in the current directory. Optionally, move the nf-test file to a directory accessible by your $PATH variable. Test the installation with the following command: nf-test version Manual installation All releases are also available on Github . Updating To update an existing nf-test installtion to the latest version, run the following command: nf-test update","title":"Installation"},{"location":"installation/#installation","text":"nf-test has the same requirements as Nextflow and can be used on POSIX compatible systems like Linux or OS X. You can install nf-test using the following command: curl -fsSL https://code.askimed.com/install/nf-test | bash If you don't have curl installed, you could use wget: wget -qO- https://code.askimed.com/install/nf-test | bash It will create the nf-test executable file in the current directory. Optionally, move the nf-test file to a directory accessible by your $PATH variable. Test the installation with the following command: nf-test version","title":"Installation"},{"location":"installation/#manual-installation","text":"All releases are also available on Github .","title":"Manual installation"},{"location":"installation/#updating","text":"To update an existing nf-test installtion to the latest version, run the following command: nf-test update","title":"Updating"},{"location":"cli/generate/","text":"generate command Usage nf-test generate <TEST_CASE_TYPE> <NEXTFLOW_FILES> Supported Types process workflow pipeline Examples Create a testcase for a process: nf-test generate process modules/local/vcf_to_plink.nf Create a testcases for all processes in folder modules : nf-test generate process modules/**/*.nf Create a testcase for a subworkflow: nf-test generate workflow workflows/vcf_workflow.nf Create a testcase for the whole pipeline: nf-test generate pipeline main.nf","title":"generate"},{"location":"cli/generate/#generate-command","text":"","title":"generate command"},{"location":"cli/generate/#usage","text":"nf-test generate <TEST_CASE_TYPE> <NEXTFLOW_FILES>","title":"Usage"},{"location":"cli/generate/#supported-types","text":"","title":"Supported Types"},{"location":"cli/generate/#process","text":"","title":"process"},{"location":"cli/generate/#workflow","text":"","title":"workflow"},{"location":"cli/generate/#pipeline","text":"","title":"pipeline"},{"location":"cli/generate/#examples","text":"Create a testcase for a process: nf-test generate process modules/local/vcf_to_plink.nf Create a testcases for all processes in folder modules : nf-test generate process modules/**/*.nf Create a testcase for a subworkflow: nf-test generate workflow workflows/vcf_workflow.nf Create a testcase for the whole pipeline: nf-test generate pipeline main.nf","title":"Examples"},{"location":"cli/init/","text":"init command Usage nf-test init","title":"init"},{"location":"cli/init/#init-command","text":"","title":"init command"},{"location":"cli/init/#usage","text":"nf-test init","title":"Usage"},{"location":"cli/test/","text":"test command Usage nf-test test [<NEXTFLOW_FILES>] Optional Arguements --profile <NEXTFLOW_PROFILE> --debug Examples Run a single test: nf-test test tests/modules/local/vcf_to_plink.nf.test Run all tests: nf-test test","title":"test"},{"location":"cli/test/#test-command","text":"","title":"test command"},{"location":"cli/test/#usage","text":"nf-test test [<NEXTFLOW_FILES>]","title":"Usage"},{"location":"cli/test/#optional-arguements","text":"","title":"Optional Arguements"},{"location":"cli/test/#-profile-nextflow_profile","text":"","title":"--profile &lt;NEXTFLOW_PROFILE&gt;"},{"location":"cli/test/#-debug","text":"","title":"--debug"},{"location":"cli/test/#examples","text":"Run a single test: nf-test test tests/modules/local/vcf_to_plink.nf.test Run all tests: nf-test test","title":"Examples"},{"location":"testcases/nextflow_pipeline/","text":"nextflow_pipeline Properties name script Example nextflow_pipeline { name \"Test Workflow test1.nf\" script \"test-data/test1.nf\" test ( \"Should run without failures\" ) { when { params { // define parameters here. Example: // outdir = \"tests/results\" } } then { assert workflow . success } } }","title":"nextflow_pipeline"},{"location":"testcases/nextflow_pipeline/#nextflow_pipeline","text":"","title":"nextflow_pipeline"},{"location":"testcases/nextflow_pipeline/#properties","text":"","title":"Properties"},{"location":"testcases/nextflow_pipeline/#name","text":"","title":"name"},{"location":"testcases/nextflow_pipeline/#script","text":"","title":"script"},{"location":"testcases/nextflow_pipeline/#example","text":"nextflow_pipeline { name \"Test Workflow test1.nf\" script \"test-data/test1.nf\" test ( \"Should run without failures\" ) { when { params { // define parameters here. Example: // outdir = \"tests/results\" } } then { assert workflow . success } } }","title":"Example"},{"location":"testcases/nextflow_process/","text":"nextflow_process Properties name script process Example nextflow_process { name \"Test Process TEST_PROCESS\" script \"test-data/test_process.nf\" process \"TEST_PROCESS\" test ( \"Should run without failures\" ) { when { params { // define parameters here. Example: // outdir = \"tests/results\" } process { \"\"\" // define inputs of the process here. Example: // input[0] = file(\"test-file.txt\") \"\"\" } } then { assert process . success with ( process . out ) { //Make assertions about the content and elements of output channels here. Example: // assert out_channel != null } } } }","title":"nextflow_process"},{"location":"testcases/nextflow_process/#nextflow_process","text":"","title":"nextflow_process"},{"location":"testcases/nextflow_process/#properties","text":"","title":"Properties"},{"location":"testcases/nextflow_process/#name","text":"","title":"name"},{"location":"testcases/nextflow_process/#script","text":"","title":"script"},{"location":"testcases/nextflow_process/#process","text":"","title":"process"},{"location":"testcases/nextflow_process/#example","text":"nextflow_process { name \"Test Process TEST_PROCESS\" script \"test-data/test_process.nf\" process \"TEST_PROCESS\" test ( \"Should run without failures\" ) { when { params { // define parameters here. Example: // outdir = \"tests/results\" } process { \"\"\" // define inputs of the process here. Example: // input[0] = file(\"test-file.txt\") \"\"\" } } then { assert process . success with ( process . out ) { //Make assertions about the content and elements of output channels here. Example: // assert out_channel != null } } } }","title":"Example"},{"location":"testcases/nextflow_workflow/","text":"nextflow_workflow Properties name script workflow Example nextflow_workflow { name \"Test Workflow TEST_WORKFLOW\" script \"test-data/test_workflow.nf\" workflow \"TEST_WORKFLOW\" test ( \"Should run without failures\" ) { when { params { // define parameters here. Example: // outdir = \"tests/results\" } workflow { \"\"\" // define inputs of the process here. Example: // input[0] = file(\"test-file.txt\") \"\"\" } } then { assert workflow . success } } }","title":"nextflow_workflow"},{"location":"testcases/nextflow_workflow/#nextflow_workflow","text":"","title":"nextflow_workflow"},{"location":"testcases/nextflow_workflow/#properties","text":"","title":"Properties"},{"location":"testcases/nextflow_workflow/#name","text":"","title":"name"},{"location":"testcases/nextflow_workflow/#script","text":"","title":"script"},{"location":"testcases/nextflow_workflow/#workflow","text":"","title":"workflow"},{"location":"testcases/nextflow_workflow/#example","text":"nextflow_workflow { name \"Test Workflow TEST_WORKFLOW\" script \"test-data/test_workflow.nf\" workflow \"TEST_WORKFLOW\" test ( \"Should run without failures\" ) { when { params { // define parameters here. Example: // outdir = \"tests/results\" } workflow { \"\"\" // define inputs of the process here. Example: // input[0] = file(\"test-file.txt\") \"\"\" } } then { assert workflow . success } } }","title":"Example"}]}