{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to nf-test \ud83d\ude80 nf-test is a simple test framework for Nextflow pipelines. Getting Started Installation Source Test your pipeline Let's start with a simple example to test the Hello World Nextflow pipeline. To run it, copy/paste the code into a text file (e.g. hello-world.test ) and run it with nf-test test hello-world.test . nextflow_pipeline { name \"Test Hello World\" script \"nextflow-io/hello\" test ( \"hello world example should start 4 processes\" ) { expect { with ( workflow ){ assert success //analyze Nextflow trace file assert trace . tasks (). size () == 4 //Verify if strings have been written to stdout object assert \"Ciao world!\" in stdout assert \"Bonjour world!\" in stdout assert \"Hello world!\" in stdout assert \"Hola world!\" in stdout } } } } Test your process In the nf-test script below we add some basic checks to a process of a recently published pipeline . nextflow_process { name \"Test Process SALMON_INDEX\" script \"modules/local/salmon_index.nf\" process \"SALMON_INDEX\" test ( \"Should create channel index files\" ) { when { process { \"\"\" input[0] = file(\"test_data/transcriptome.fa\") \"\"\" } } then { //check if test case succeeded assert process . success //analyze trace file assert process . trace . tasks (). size () == 1 with ( process . out ) { // check if emitted output has been created assert index . size () == 1 // count amount of created files assert path ( index . get ( 0 )). list (). size () == 16 // parse info.json file def info = path ( index . get ( 0 )+ '/info.json' ). json assert info . num_kmers == 375730 assert info . seq_length == 443050 //verify md5 checksum assert path ( index . get ( 0 )+ '/info.json' ). md5 == \"80831602e2ac825e3e63ba9df5d23505\" } } } }","title":"Home"},{"location":"#welcome-to-nf-test","text":"nf-test is a simple test framework for Nextflow pipelines. Getting Started Installation Source","title":"Welcome to nf-test \ud83d\ude80"},{"location":"#test-your-pipeline","text":"Let's start with a simple example to test the Hello World Nextflow pipeline. To run it, copy/paste the code into a text file (e.g. hello-world.test ) and run it with nf-test test hello-world.test . nextflow_pipeline { name \"Test Hello World\" script \"nextflow-io/hello\" test ( \"hello world example should start 4 processes\" ) { expect { with ( workflow ){ assert success //analyze Nextflow trace file assert trace . tasks (). size () == 4 //Verify if strings have been written to stdout object assert \"Ciao world!\" in stdout assert \"Bonjour world!\" in stdout assert \"Hello world!\" in stdout assert \"Hola world!\" in stdout } } } }","title":"Test your pipeline"},{"location":"#test-your-process","text":"In the nf-test script below we add some basic checks to a process of a recently published pipeline . nextflow_process { name \"Test Process SALMON_INDEX\" script \"modules/local/salmon_index.nf\" process \"SALMON_INDEX\" test ( \"Should create channel index files\" ) { when { process { \"\"\" input[0] = file(\"test_data/transcriptome.fa\") \"\"\" } } then { //check if test case succeeded assert process . success //analyze trace file assert process . trace . tasks (). size () == 1 with ( process . out ) { // check if emitted output has been created assert index . size () == 1 // count amount of created files assert path ( index . get ( 0 )). list (). size () == 16 // parse info.json file def info = path ( index . get ( 0 )+ '/info.json' ). json assert info . num_kmers == 375730 assert info . seq_length == 443050 //verify md5 checksum assert path ( index . get ( 0 )+ '/info.json' ). md5 == \"80831602e2ac825e3e63ba9df5d23505\" } } } }","title":"Test your process"},{"location":"about/","text":"nf-test has been created by Lukas Forer and Sebastian Sch\u00f6nherr .","title":"About"},{"location":"configuration/","text":"Configuration Setup test profile To run your test using a specific Netxflow profile, you can use the --profile argument on the command line or define a default profile in nf-test.config . nf-test.config This config file contains settings for nf-test. config { // location for all nf-tests testsDir \"tests\" // nf-test directory including temporary files for each test workDir \".nf-test\" // location of an optional nextflow.config file specific for executing tests configFile \"tests/nextflow.config\" // location of library folder that is added automatically to the classpath libDir \"tests/lib\" // run all test with the defined docker profile from the main nextflow.config profile \"docker\" // disable tracing options in case container does not include `procps` Linux tool. withTrace = false } tests/nextflow.config This optional nextflow.config file is used to execute tests. This is a good place to set default params for all your tests. Example number of threads: params { // run all tests with 1 threads threads = 1 } Configuration for tests nf-test allows to set an additional configuration for a testsuite: nextflow_process { name \"Test Process...\" script \"main.nf\" process \"my_process\" config \"path/to/test/nextflow.config\" ... } It is also possible to overwrite the config property for a specific test: nextflow_process { test(\"my test\") { config \"path/to/test/nextflow.config\" ... } }","title":"Configuration"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/#setup-test-profile","text":"To run your test using a specific Netxflow profile, you can use the --profile argument on the command line or define a default profile in nf-test.config .","title":"Setup test profile"},{"location":"configuration/#nf-testconfig","text":"This config file contains settings for nf-test. config { // location for all nf-tests testsDir \"tests\" // nf-test directory including temporary files for each test workDir \".nf-test\" // location of an optional nextflow.config file specific for executing tests configFile \"tests/nextflow.config\" // location of library folder that is added automatically to the classpath libDir \"tests/lib\" // run all test with the defined docker profile from the main nextflow.config profile \"docker\" // disable tracing options in case container does not include `procps` Linux tool. withTrace = false }","title":"nf-test.config"},{"location":"configuration/#testsnextflowconfig","text":"This optional nextflow.config file is used to execute tests. This is a good place to set default params for all your tests. Example number of threads: params { // run all tests with 1 threads threads = 1 }","title":"tests/nextflow.config"},{"location":"configuration/#configuration-for-tests","text":"nf-test allows to set an additional configuration for a testsuite: nextflow_process { name \"Test Process...\" script \"main.nf\" process \"my_process\" config \"path/to/test/nextflow.config\" ... } It is also possible to overwrite the config property for a specific test: nextflow_process { test(\"my test\") { config \"path/to/test/nextflow.config\" ... } }","title":"Configuration for tests"},{"location":"getting-started/","text":"Getting started This guide helps you to understand the concepts of nf-test and to write your first test cases. Before you start, please check if you have installed nf-test properly on your computer. Also, this guide assumes that you have a basic knowledge of Groovy and unit testing. The Groovy documentation is the best place to learn its syntax. Let's get started To show the power of nf-test, we adapted a recently published proof of concept Nextflow pipeline . We adapted the pipeline to the new DSL2 syntax using modules. First, open the terminal and clone our test pipeline: # clone nextflow pipeline git clone https://github.com/askimed/nf-test-examples # enter project directory cd nf-test-examples The pipeline consists of three modules ( salmon.index.nf , salmon_align_quant.nf , fastqc.nf ). Here, we use the salmon.index.nf process to create a test case from scratch. This process takes a reference as an input and creates an index using salmon. Init Before creating test cases, we use the init command to setup nf-test. //Init command has already been executed for our repository nf-test init The init command creates the following files: nf-test.config and the .nf-test/tests folder. In the configuration section you can learn more about these files and how to customize the directory layout. Create your first test The generate command helps you to create a skeleton test code for a Nextflow process or the complete pipeline/workflow. Here we generate a test case for the process salmon.index.nf : # delete already existing test case rm tests/modules/local/salmon_index.nf.test nf-test generate process modules/local/salmon_index.nf This command creates a new file tests/modules/local/salmon_index.nf with the following content: nextflow_process { name \"Test Process SALMON_INDEX\" script \"modules/local/salmon_index.nf\" process \"SALMON_INDEX\" test ( \"Should run without failures\" ) { when { params { // define parameters here. Example: // outdir = \"tests/results\" } process { \"\"\" // define inputs of the process here. Example: // input[0] = file(\"test-file.txt\") \"\"\" } } then { assert process . success with ( process . out ) { // Make assertions about the content and elements of output channels here. Example: // assert out_channel != null } } } } The generate command filled automatically the name, script and process of our test case as well as created a skeleton for your first test method. Typically you create one file per process and use different test methods to describe the expected behaviour of the process. This test has a name, a when and a then closure (when/then closures are required here, since inputs need to be defined). The when block describes the input parameters of the workflow or the process. nf-test executes the process with exactly these parameters and parses the content of the output channels. Then, it evaluates the assertions defined in the then block to check if content of the output channels matches your expectations. The when block The when block describes the input of the process and/or the Nextflow params . The params block is optional and is a simple map that can be used to override Nextflow's input params . The process block is a multi-line string. The input array can be used to set the different inputs arguments of the process. In our example, we only have one input that expects a file. Let us update the process block by setting the first element of the input array to the path of our reference file: when { params { outdir = \"output\" } process { \"\"\" // Use transcriptome.fa as a first input paramter for our process input[0] = file(\"test_data/transcriptome.fa\") \"\"\" } } Everything which is defined in the process block is later executed in a Nextflow script (created automatically to test your process). Therefore, you can use every Nextflow specific function or command to define the values of the input array (e.g. Channels, files, paths, etc.). The then block The then block describes the expected output channels of the process when we execute it with the input parameters defined in the when block. The then block typically contains mainly assertions to check assumptions (e.g. the size and the content of an output channel). However, this block accepts every Groovy script. This means you can also import third party libraries to define very specific assertions. nf-test automatically loads all output channels of the process and all their items into a map named process.out . You can then use this map to formulate your assertions. For example, in the salmon_index process we expect to get one process executed and 16 files created. But we also want to check the md5 sum and want to look into the actual JSON file. Let us update the then section with some assertions that describe our expectations: then { //check if test case succeeded assert process . success //analyze trace file assert process . trace . tasks (). size () == 1 with ( process . out ) { // check if emitted output has been created assert index . size () == 1 // count amount of created files assert path ( index . get ( 0 )). list (). size () == 16 // parse info.json file using a json parser provided by nf-test def info = path ( index . get ( 0 )+ '/info.json' ). json assert info . num_kmers == 375730 assert info . seq_length == 443050 assert path ( index . get ( 0 )+ '/info.json' ). md5 == \"80831602e2ac825e3e63ba9df5d23505\" } } The items of a channel are always sorted by nf-test. This provides a deterministic order inside the channel and enables you to write reproducible tests. Your first test specification You can update the name of the test method to something that gives us later a good description of our specification. When we put everything together, we get the following full working test specification: nextflow_process { name \"Test Process SALMON_INDEX\" script \"modules/local/salmon_index.nf\" process \"SALMON_INDEX\" test ( \"Should create channel index files\" ) { when { process { \"\"\" input[0] = file(\"test_data/transcriptome.fa\") \"\"\" } } then { //check if test case succeeded assert process . success //analyze trace file assert process . trace . tasks (). size () == 1 with ( process . out ) { // check if emitted output has been created assert index . size () == 1 // count amount of created files assert path ( index . get ( 0 )). list (). size () == 16 // parse info.json file def info = path ( index . get ( 0 )+ '/info.json' ). json assert info . num_kmers == 375730 assert info . seq_length == 443050 assert path ( index . get ( 0 )+ '/info.json' ). md5 == \"80831602e2ac825e3e63ba9df5d23505\" } } } } Run your first test Now, the test command can be used to run your test: nf-test test tests/modules/local/salmon_index.nf.test --profile docker Specifying profiles In this case, the docker profile defined in the Nextflow pipeline is used to execute the test. The profile is set using the --profile parameter, but you can also define a default profile in the configuration file . Congratulations! You created you first nf-test specification. What's next? Learn how to write assertions Learn how to write workflow tests (integration test or e2e) Learn how to config nf-test","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"This guide helps you to understand the concepts of nf-test and to write your first test cases. Before you start, please check if you have installed nf-test properly on your computer. Also, this guide assumes that you have a basic knowledge of Groovy and unit testing. The Groovy documentation is the best place to learn its syntax.","title":"Getting started"},{"location":"getting-started/#lets-get-started","text":"To show the power of nf-test, we adapted a recently published proof of concept Nextflow pipeline . We adapted the pipeline to the new DSL2 syntax using modules. First, open the terminal and clone our test pipeline: # clone nextflow pipeline git clone https://github.com/askimed/nf-test-examples # enter project directory cd nf-test-examples The pipeline consists of three modules ( salmon.index.nf , salmon_align_quant.nf , fastqc.nf ). Here, we use the salmon.index.nf process to create a test case from scratch. This process takes a reference as an input and creates an index using salmon.","title":"Let's get started"},{"location":"getting-started/#init","text":"Before creating test cases, we use the init command to setup nf-test. //Init command has already been executed for our repository nf-test init The init command creates the following files: nf-test.config and the .nf-test/tests folder. In the configuration section you can learn more about these files and how to customize the directory layout.","title":"Init"},{"location":"getting-started/#create-your-first-test","text":"The generate command helps you to create a skeleton test code for a Nextflow process or the complete pipeline/workflow. Here we generate a test case for the process salmon.index.nf : # delete already existing test case rm tests/modules/local/salmon_index.nf.test nf-test generate process modules/local/salmon_index.nf This command creates a new file tests/modules/local/salmon_index.nf with the following content: nextflow_process { name \"Test Process SALMON_INDEX\" script \"modules/local/salmon_index.nf\" process \"SALMON_INDEX\" test ( \"Should run without failures\" ) { when { params { // define parameters here. Example: // outdir = \"tests/results\" } process { \"\"\" // define inputs of the process here. Example: // input[0] = file(\"test-file.txt\") \"\"\" } } then { assert process . success with ( process . out ) { // Make assertions about the content and elements of output channels here. Example: // assert out_channel != null } } } } The generate command filled automatically the name, script and process of our test case as well as created a skeleton for your first test method. Typically you create one file per process and use different test methods to describe the expected behaviour of the process. This test has a name, a when and a then closure (when/then closures are required here, since inputs need to be defined). The when block describes the input parameters of the workflow or the process. nf-test executes the process with exactly these parameters and parses the content of the output channels. Then, it evaluates the assertions defined in the then block to check if content of the output channels matches your expectations.","title":"Create your first test"},{"location":"getting-started/#the-when-block","text":"The when block describes the input of the process and/or the Nextflow params . The params block is optional and is a simple map that can be used to override Nextflow's input params . The process block is a multi-line string. The input array can be used to set the different inputs arguments of the process. In our example, we only have one input that expects a file. Let us update the process block by setting the first element of the input array to the path of our reference file: when { params { outdir = \"output\" } process { \"\"\" // Use transcriptome.fa as a first input paramter for our process input[0] = file(\"test_data/transcriptome.fa\") \"\"\" } } Everything which is defined in the process block is later executed in a Nextflow script (created automatically to test your process). Therefore, you can use every Nextflow specific function or command to define the values of the input array (e.g. Channels, files, paths, etc.).","title":"The when block"},{"location":"getting-started/#the-then-block","text":"The then block describes the expected output channels of the process when we execute it with the input parameters defined in the when block. The then block typically contains mainly assertions to check assumptions (e.g. the size and the content of an output channel). However, this block accepts every Groovy script. This means you can also import third party libraries to define very specific assertions. nf-test automatically loads all output channels of the process and all their items into a map named process.out . You can then use this map to formulate your assertions. For example, in the salmon_index process we expect to get one process executed and 16 files created. But we also want to check the md5 sum and want to look into the actual JSON file. Let us update the then section with some assertions that describe our expectations: then { //check if test case succeeded assert process . success //analyze trace file assert process . trace . tasks (). size () == 1 with ( process . out ) { // check if emitted output has been created assert index . size () == 1 // count amount of created files assert path ( index . get ( 0 )). list (). size () == 16 // parse info.json file using a json parser provided by nf-test def info = path ( index . get ( 0 )+ '/info.json' ). json assert info . num_kmers == 375730 assert info . seq_length == 443050 assert path ( index . get ( 0 )+ '/info.json' ). md5 == \"80831602e2ac825e3e63ba9df5d23505\" } } The items of a channel are always sorted by nf-test. This provides a deterministic order inside the channel and enables you to write reproducible tests.","title":"The then block"},{"location":"getting-started/#your-first-test-specification","text":"You can update the name of the test method to something that gives us later a good description of our specification. When we put everything together, we get the following full working test specification: nextflow_process { name \"Test Process SALMON_INDEX\" script \"modules/local/salmon_index.nf\" process \"SALMON_INDEX\" test ( \"Should create channel index files\" ) { when { process { \"\"\" input[0] = file(\"test_data/transcriptome.fa\") \"\"\" } } then { //check if test case succeeded assert process . success //analyze trace file assert process . trace . tasks (). size () == 1 with ( process . out ) { // check if emitted output has been created assert index . size () == 1 // count amount of created files assert path ( index . get ( 0 )). list (). size () == 16 // parse info.json file def info = path ( index . get ( 0 )+ '/info.json' ). json assert info . num_kmers == 375730 assert info . seq_length == 443050 assert path ( index . get ( 0 )+ '/info.json' ). md5 == \"80831602e2ac825e3e63ba9df5d23505\" } } } }","title":"Your first test specification"},{"location":"getting-started/#run-your-first-test","text":"Now, the test command can be used to run your test: nf-test test tests/modules/local/salmon_index.nf.test --profile docker","title":"Run your first test"},{"location":"getting-started/#specifying-profiles","text":"In this case, the docker profile defined in the Nextflow pipeline is used to execute the test. The profile is set using the --profile parameter, but you can also define a default profile in the configuration file . Congratulations! You created you first nf-test specification.","title":"Specifying profiles"},{"location":"getting-started/#whats-next","text":"Learn how to write assertions Learn how to write workflow tests (integration test or e2e) Learn how to config nf-test","title":"What's next?"},{"location":"installation/","text":"Installation nf-test has the same requirements as Nextflow and can be used on POSIX compatible systems like Linux or OS X. You can install nf-test using the following command: curl -fsSL https://code.askimed.com/install/nf-test | bash If you don't have curl installed, you could use wget: wget -qO- https://code.askimed.com/install/nf-test | bash It will create the nf-test executable file in the current directory. Optionally, move the nf-test file to a directory accessible by your $PATH variable. Test the installation with the following command: nf-test version You should see something like this: \ud83d\ude80 nf-test 0.5.0 https://code.askimed.com/nf-test (c) 2021 -2022 Lukas Forer and Sebastian Schoenherr Nextflow Runtime: N E X T F L O W version 21.10.6 build 5660 created 21-12-2021 16:55 UTC (17:55 CEST) cite doi:10.1038/nbt.3820 http://nextflow.io Now you are ready to write your first testcase . Nextflow Binary not found If you get an error message like this, then nf-test was not able to detect your Nextflow installation. \ud83d\ude80 nf-test 0.5.0 https://code.askimed.com/nf-test (c) 2021 -2022 Lukas Forer and Sebastian Schoenherr Nextflow Runtime: Error: Nextflow Binary not found. Please check if Nextflow is in a directory accessible by your $PATH variable or set $NEXTFLOW_HOME. To solve this issue you have two possibilites: Move your Nextflow binary to a directory accessible by your $PATH variable. Set the environment variable NEXTFLOW_HOME to the directory that contains the Nextflow binary. Updating To update an existing nf-test installtion to the latest version, run the following command: nf-test update Manual installation All releases are also available on Github .","title":"Installation"},{"location":"installation/#installation","text":"nf-test has the same requirements as Nextflow and can be used on POSIX compatible systems like Linux or OS X. You can install nf-test using the following command: curl -fsSL https://code.askimed.com/install/nf-test | bash If you don't have curl installed, you could use wget: wget -qO- https://code.askimed.com/install/nf-test | bash It will create the nf-test executable file in the current directory. Optionally, move the nf-test file to a directory accessible by your $PATH variable. Test the installation with the following command: nf-test version You should see something like this: \ud83d\ude80 nf-test 0.5.0 https://code.askimed.com/nf-test (c) 2021 -2022 Lukas Forer and Sebastian Schoenherr Nextflow Runtime: N E X T F L O W version 21.10.6 build 5660 created 21-12-2021 16:55 UTC (17:55 CEST) cite doi:10.1038/nbt.3820 http://nextflow.io Now you are ready to write your first testcase .","title":"Installation"},{"location":"installation/#nextflow-binary-not-found","text":"If you get an error message like this, then nf-test was not able to detect your Nextflow installation. \ud83d\ude80 nf-test 0.5.0 https://code.askimed.com/nf-test (c) 2021 -2022 Lukas Forer and Sebastian Schoenherr Nextflow Runtime: Error: Nextflow Binary not found. Please check if Nextflow is in a directory accessible by your $PATH variable or set $NEXTFLOW_HOME. To solve this issue you have two possibilites: Move your Nextflow binary to a directory accessible by your $PATH variable. Set the environment variable NEXTFLOW_HOME to the directory that contains the Nextflow binary.","title":"Nextflow Binary not found"},{"location":"installation/#updating","text":"To update an existing nf-test installtion to the latest version, run the following command: nf-test update","title":"Updating"},{"location":"installation/#manual-installation","text":"All releases are also available on Github .","title":"Manual installation"},{"location":"nftest_pipelines/","text":"Pipelines using nf-test nf-test-examples All test cases described in this documentation can be found in the nf-test-examples repository . GWAS-Regenie Pipeline To show the power of nf-test, we applied nf-test to a Nextflow pipeline that performs whole genome regression modelling using regenie. Please click here to learn more about this pipeline and checkout different kind of test cases.","title":"Available Pipelines"},{"location":"nftest_pipelines/#pipelines-using-nf-test","text":"","title":"Pipelines using nf-test"},{"location":"nftest_pipelines/#nf-test-examples","text":"All test cases described in this documentation can be found in the nf-test-examples repository .","title":"nf-test-examples"},{"location":"nftest_pipelines/#gwas-regenie-pipeline","text":"To show the power of nf-test, we applied nf-test to a Nextflow pipeline that performs whole genome regression modelling using regenie. Please click here to learn more about this pipeline and checkout different kind of test cases.","title":"GWAS-Regenie Pipeline"},{"location":"assertions/assertions/","text":"Assertions Writing test cases means formulating assumptions by using assertions. Groovy\u2019s power assert provides a detailed output when the boolean expression validates to false. nf-test provides several extensions and commands to simplify the work with Nextflow channels. Using with This assertions... assert process . out . imputed_plink2 assert process . out . imputed_plink2 . size () == 1 assert process . out . imputed_plink2 . get ( 0 ). get ( 0 ) == \"example.vcf\" assert process . out . imputed_plink2 . get ( 0 ). get ( 1 ) ==~ \".*/example.vcf.pgen\" assert process . out . imputed_plink2 . get ( 0 ). get ( 2 ) ==~ \".*/example.vcf.psam\" assert process . out . imputed_plink2 . get ( 0 ). get ( 3 ) ==~ \".*/example.vcf.pvar\" ... can be written by using with(){} to improve readability: assert process . out . imputed_plink2 with ( process . out . imputed_plink2 ) { assert size () == 1 with ( get ( 0 )) { assert get ( 0 ) == \"example.vcf\" assert get ( 1 ) ==~ \".*/example.vcf.pgen\" assert get ( 2 ) ==~ \".*/example.vcf.psam\" assert get ( 3 ) ==~ \".*/example.vcf.pvar\" } }","title":"Power Assertions"},{"location":"assertions/assertions/#assertions","text":"Writing test cases means formulating assumptions by using assertions. Groovy\u2019s power assert provides a detailed output when the boolean expression validates to false. nf-test provides several extensions and commands to simplify the work with Nextflow channels.","title":"Assertions"},{"location":"assertions/assertions/#using-with","text":"This assertions... assert process . out . imputed_plink2 assert process . out . imputed_plink2 . size () == 1 assert process . out . imputed_plink2 . get ( 0 ). get ( 0 ) == \"example.vcf\" assert process . out . imputed_plink2 . get ( 0 ). get ( 1 ) ==~ \".*/example.vcf.pgen\" assert process . out . imputed_plink2 . get ( 0 ). get ( 2 ) ==~ \".*/example.vcf.psam\" assert process . out . imputed_plink2 . get ( 0 ). get ( 3 ) ==~ \".*/example.vcf.pvar\" ... can be written by using with(){} to improve readability: assert process . out . imputed_plink2 with ( process . out . imputed_plink2 ) { assert size () == 1 with ( get ( 0 )) { assert get ( 0 ) == \"example.vcf\" assert get ( 1 ) ==~ \".*/example.vcf.pgen\" assert get ( 2 ) ==~ \".*/example.vcf.psam\" assert get ( 3 ) ==~ \".*/example.vcf.pvar\" } }","title":"Using with"},{"location":"assertions/fasta/","text":"FASTA Files 0.7.0 The nft-fasta plugin extends path by a fasta property that can be used to read FASTA files into maps. nft-fasta supports also gzipped FASTA files. Setup To use the fasta property you need to activate the nft-fasta plugin in your nf-test.config file: config { plugins { load \"nft-fasta@1.0.0\" } } More about plugins can be fond here . Comparing files assert path ( 'path/to/fasta1.fasta' ). fasta == path ( \"path/to/fasta2.fasta'\" ). fasta Work with individual samples def sequences = path ( 'path/to/fasta1.fasta.gz' ). fasta assert \"seq1\" in sequences assert !( \"seq8\" in sequences ) assert sequences . seq1 == \"AGTACGTAGTAGCTGCTGCTACGTGCGCTAGCTAGTACGTCACGACGTAGATGCTAGCTGACTCGATGC\"","title":"FASTA Files"},{"location":"assertions/fasta/#fasta-files","text":"0.7.0 The nft-fasta plugin extends path by a fasta property that can be used to read FASTA files into maps. nft-fasta supports also gzipped FASTA files.","title":"FASTA Files"},{"location":"assertions/fasta/#setup","text":"To use the fasta property you need to activate the nft-fasta plugin in your nf-test.config file: config { plugins { load \"nft-fasta@1.0.0\" } } More about plugins can be fond here .","title":"Setup"},{"location":"assertions/fasta/#comparing-files","text":"assert path ( 'path/to/fasta1.fasta' ). fasta == path ( \"path/to/fasta2.fasta'\" ). fasta","title":"Comparing files"},{"location":"assertions/fasta/#work-with-individual-samples","text":"def sequences = path ( 'path/to/fasta1.fasta.gz' ). fasta assert \"seq1\" in sequences assert !( \"seq8\" in sequences ) assert sequences . seq1 == \"AGTACGTAGTAGCTGCTGCTACGTGCGCTAGCTAGTACGTCACGACGTAGATGCTAGCTGACTCGATGC\"","title":"Work with individual samples"},{"location":"assertions/files/","text":"Files md5 Checksum nf-test extends path by a md5 property that can be used to compare the file content with an expected checksum: assert path ( process . out . out_ch . get ( 0 )). md5 == \"64debea5017a035ddc67c0b51fa84b16\" JSON Files nf-test extends path by a json property that can be used to read json files: assert path ( process . out . out_ch . get ( 0 )). json . key == \"value\" GZip Files nf-test extends path by a linesGzip property that can be used to read gzip compressed files: assert path ( process . out . out_ch . get ( 0 )). linesGzip . size == 5 assert path ( process . out . out_ch . get ( 0 )). linesGzip . contains ( \"Line Content\" )","title":"Files"},{"location":"assertions/files/#files","text":"","title":"Files"},{"location":"assertions/files/#md5-checksum","text":"nf-test extends path by a md5 property that can be used to compare the file content with an expected checksum: assert path ( process . out . out_ch . get ( 0 )). md5 == \"64debea5017a035ddc67c0b51fa84b16\"","title":"md5 Checksum"},{"location":"assertions/files/#json-files","text":"nf-test extends path by a json property that can be used to read json files: assert path ( process . out . out_ch . get ( 0 )). json . key == \"value\"","title":"JSON Files"},{"location":"assertions/files/#gzip-files","text":"nf-test extends path by a linesGzip property that can be used to read gzip compressed files: assert path ( process . out . out_ch . get ( 0 )). linesGzip . size == 5 assert path ( process . out . out_ch . get ( 0 )). linesGzip . contains ( \"Line Content\" )","title":"GZip Files"},{"location":"assertions/libraries/","text":"Using Third-Party Libraries nf-test supports including third party libraries (e.g. jar files ) or functions from groovy files to either extend it functionality or to avoid duplicate code and to keep the logic in test cases simple. Using Local Files 0.7.0 \u00b7 If nf-test detects a lib folder in the directory of a tescase, then it adds it automatically to the classpath. Examples We have a Groovy script MyWordUtils.groovy that contains the following class: class MyWordUtils { def static capitalize ( String word ){ return word . toUpperCase (); } } We can put this file in a subfolder called lib : testcase_1 \u251c\u2500\u2500 hello_1.nf \u251c\u2500\u2500 hello_1.nf.test \u2514\u2500\u2500 lib \u2514\u2500\u2500 MyWordUtils.groovy Next, we can use this class in the hello_1.nf.test like every other class that is provided by nf-test or Groovy itself: nextflow_process { name \"Test Process CAPITALIZER\" script \"test-data/capitalizer.nf\" process \"CAPITALIZER\" test ( \"Should run without failures\" ) { when { process { \"\"\" input[0] = \"world\" \"\"\" } } then { assert process . success assert process . stdout . contains ( MyWordUtils . capitalize ( 'world' )) } } } If we have a project and we want to reuse libraries in multiple test cases, then we can store the class in the shared lib folder. Both test cases are now able to use MyWordUtils : tests \u251c\u2500\u2500 testcase_1 \u251c\u2500\u2500 hello_1.nf \u251c\u2500\u2500 hello_1.nf.test \u251c\u2500\u2500 testcase_2 \u251c\u2500\u2500 hello_2.nf \u251c\u2500\u2500 hello_2.nf.test \u2514\u2500\u2500 lib \u2514\u2500\u2500 MyWordUtils.groovy The default location is tests\\lib . This folder location can be changed in nf-test config file. It is also possible to use the --lib parameter to add an additional folder to the classpath: nf-test test tests/testcase_1/hello_1.nf --lib tests/mylibs If multiple folders are used, the they need to be separate with a colon (like in Java or Groovy). Using Maven Artifcats with @Grab nf-test supports the @Grab annotation to include third-party libraries that are available in a maven repository. As the dependency is defined as a maven artifact, there is no local copy of the jar file needed and maven enables to include an exact version as well as provides an easy update process. Example The following example uses the WordUtil class from commons-lang : @Grab ( group = 'commons-lang' , module = 'commons-lang' , version = '2.4' ) import org.apache.commons.lang.WordUtils nextflow_process { name \"Test Process CAPITALIZER\" script \"test-data/capitalizer.nf\" process \"CAPITALIZER\" test ( \"Should run without failures\" ) { when { process { \"\"\" input[0] = \"world\" \"\"\" } } then { assert process . success assert process . stdout . contains ( WordUtils . capitalize ( 'world' )) } } }","title":"Using Third-Party Libraries"},{"location":"assertions/libraries/#using-third-party-libraries","text":"nf-test supports including third party libraries (e.g. jar files ) or functions from groovy files to either extend it functionality or to avoid duplicate code and to keep the logic in test cases simple.","title":"Using Third-Party Libraries"},{"location":"assertions/libraries/#using-local-files","text":"0.7.0 \u00b7 If nf-test detects a lib folder in the directory of a tescase, then it adds it automatically to the classpath.","title":"Using Local Files"},{"location":"assertions/libraries/#examples","text":"We have a Groovy script MyWordUtils.groovy that contains the following class: class MyWordUtils { def static capitalize ( String word ){ return word . toUpperCase (); } } We can put this file in a subfolder called lib : testcase_1 \u251c\u2500\u2500 hello_1.nf \u251c\u2500\u2500 hello_1.nf.test \u2514\u2500\u2500 lib \u2514\u2500\u2500 MyWordUtils.groovy Next, we can use this class in the hello_1.nf.test like every other class that is provided by nf-test or Groovy itself: nextflow_process { name \"Test Process CAPITALIZER\" script \"test-data/capitalizer.nf\" process \"CAPITALIZER\" test ( \"Should run without failures\" ) { when { process { \"\"\" input[0] = \"world\" \"\"\" } } then { assert process . success assert process . stdout . contains ( MyWordUtils . capitalize ( 'world' )) } } } If we have a project and we want to reuse libraries in multiple test cases, then we can store the class in the shared lib folder. Both test cases are now able to use MyWordUtils : tests \u251c\u2500\u2500 testcase_1 \u251c\u2500\u2500 hello_1.nf \u251c\u2500\u2500 hello_1.nf.test \u251c\u2500\u2500 testcase_2 \u251c\u2500\u2500 hello_2.nf \u251c\u2500\u2500 hello_2.nf.test \u2514\u2500\u2500 lib \u2514\u2500\u2500 MyWordUtils.groovy The default location is tests\\lib . This folder location can be changed in nf-test config file. It is also possible to use the --lib parameter to add an additional folder to the classpath: nf-test test tests/testcase_1/hello_1.nf --lib tests/mylibs If multiple folders are used, the they need to be separate with a colon (like in Java or Groovy).","title":"Examples"},{"location":"assertions/libraries/#using-maven-artifcats-with-grab","text":"nf-test supports the @Grab annotation to include third-party libraries that are available in a maven repository. As the dependency is defined as a maven artifact, there is no local copy of the jar file needed and maven enables to include an exact version as well as provides an easy update process.","title":"Using Maven Artifcats with @Grab"},{"location":"assertions/libraries/#example","text":"The following example uses the WordUtil class from commons-lang : @Grab ( group = 'commons-lang' , module = 'commons-lang' , version = '2.4' ) import org.apache.commons.lang.WordUtils nextflow_process { name \"Test Process CAPITALIZER\" script \"test-data/capitalizer.nf\" process \"CAPITALIZER\" test ( \"Should run without failures\" ) { when { process { \"\"\" input[0] = \"world\" \"\"\" } } then { assert process . success assert process . stdout . contains ( WordUtils . capitalize ( 'world' )) } } }","title":"Example"},{"location":"assertions/regular-expressions/","text":"Regular Expressions Using ==~ operator The operator ==~ can be used to check if a string matches a regular expression: assert \"/my/full/path/to/process/dir/example.vcf.pgen\" ==~ \".*/example.vcf.pgen\"","title":"Regular Expressions"},{"location":"assertions/regular-expressions/#regular-expressions","text":"","title":"Regular Expressions"},{"location":"assertions/regular-expressions/#using-operator","text":"The operator ==~ can be used to check if a string matches a regular expression: assert \"/my/full/path/to/process/dir/example.vcf.pgen\" ==~ \".*/example.vcf.pgen\"","title":"Using ==~ operator"},{"location":"assertions/snapshots/","text":"Snapshots 0.7.0 \u00b7 Snapshots are a very useful tool whenever you want to make sure your output channels or output files not change unexpectedly. This feature is highly inspired by Jest . A typical snapshot test case takes a snapshot of the output channels or any other object, then compares it to a reference snapshot file stored alongside the test ( *.nf.test.snap ). The test will fail, if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new output of a process, workflow, pipeline or function. Using Snapshots The snapshot keyword creates a snapshot of the object and its match method can then be used to check if its contains the expected data from the snap file. The following example shows how to create a snapshot of a workflow channel: assert snapshot(workflow.out.channel1).match() You can also create a snapshot of all output channels of a process: assert snapshot(process.out).match() Even the result of a function can be used: assert snapshot(function.result).match() The first time this test runs, nf-test creates a snapshot file. This is a json file that contains a serialized version of the provided object. The snapshot file should be committed alongside code changes, and reviewed as part of your code review process. nf-test uses pretty-format to make snapshots human-readable during code review. On subsequent test runs, nf-test will compare the data with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code that should be fixed, or the implementation has changed and the snapshot needs to be updated. Updating Snapshots When a snapshot test is failing due to an intentional implementation change, you can use the --update-snapshot flag to re-generate snapshots for all failed tests. nf-test test tests/main.nf.test --update-snapshot More Examples It is also possible to include multiple objects into one snapshot: assert snapshot(workflow.out.channel1, workflow.out.channel2).match() Every object that is serializable can be included into snapshots. Therefore you can even make a snapshot of the complete workflow or process object. This includes stdout, stderr, exist status, trace etc. and is the easiest way to create a test that checks for all of this properties: assert snapshot(workflow).match() You can also include output files to a snapshot (e.g. useful in pipeline tests where no channels are available): assert snapshot( workflow, path(\"${params.outdir}/file1.txt\"), path(\"${params.outdir}/file2.txt\"), path(\"${params.outdir}/file3.txt\") ).match() By default the snapshot has the same name as the test. You can also store a snapshot under a user defined name. This enables you to use multiple snapshots in one single test and to separate them in a logical way. In the following example a workflow snapshot is created, stored under the name \"workflow\". The second example, creates a snaphot of two files and saves it under \"files\". assert snapshot(workflow).match(\"workflow\") assert snapshot(path(\"${params.outdir}/file1.txt\"), path(\"${params.outdir}/file2.txt\")).match(\"files\") You can also use helper methods to add objects to snapshots. For example, you can use the list() method to add all files of a folder to a snapshot: assert snapshot(workflow, path(params.outdir).list()).match() File Paths If nf-test detects a path in the snapshot it automatically replace it by a unique fingerprint of the file that ensures the file content is the same. The fingerprint is default the md5 sum.","title":"Snapshots"},{"location":"assertions/snapshots/#snapshots","text":"0.7.0 \u00b7 Snapshots are a very useful tool whenever you want to make sure your output channels or output files not change unexpectedly. This feature is highly inspired by Jest . A typical snapshot test case takes a snapshot of the output channels or any other object, then compares it to a reference snapshot file stored alongside the test ( *.nf.test.snap ). The test will fail, if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new output of a process, workflow, pipeline or function.","title":"Snapshots"},{"location":"assertions/snapshots/#using-snapshots","text":"The snapshot keyword creates a snapshot of the object and its match method can then be used to check if its contains the expected data from the snap file. The following example shows how to create a snapshot of a workflow channel: assert snapshot(workflow.out.channel1).match() You can also create a snapshot of all output channels of a process: assert snapshot(process.out).match() Even the result of a function can be used: assert snapshot(function.result).match() The first time this test runs, nf-test creates a snapshot file. This is a json file that contains a serialized version of the provided object. The snapshot file should be committed alongside code changes, and reviewed as part of your code review process. nf-test uses pretty-format to make snapshots human-readable during code review. On subsequent test runs, nf-test will compare the data with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code that should be fixed, or the implementation has changed and the snapshot needs to be updated.","title":"Using Snapshots"},{"location":"assertions/snapshots/#updating-snapshots","text":"When a snapshot test is failing due to an intentional implementation change, you can use the --update-snapshot flag to re-generate snapshots for all failed tests. nf-test test tests/main.nf.test --update-snapshot","title":"Updating Snapshots"},{"location":"assertions/snapshots/#more-examples","text":"It is also possible to include multiple objects into one snapshot: assert snapshot(workflow.out.channel1, workflow.out.channel2).match() Every object that is serializable can be included into snapshots. Therefore you can even make a snapshot of the complete workflow or process object. This includes stdout, stderr, exist status, trace etc. and is the easiest way to create a test that checks for all of this properties: assert snapshot(workflow).match() You can also include output files to a snapshot (e.g. useful in pipeline tests where no channels are available): assert snapshot( workflow, path(\"${params.outdir}/file1.txt\"), path(\"${params.outdir}/file2.txt\"), path(\"${params.outdir}/file3.txt\") ).match() By default the snapshot has the same name as the test. You can also store a snapshot under a user defined name. This enables you to use multiple snapshots in one single test and to separate them in a logical way. In the following example a workflow snapshot is created, stored under the name \"workflow\". The second example, creates a snaphot of two files and saves it under \"files\". assert snapshot(workflow).match(\"workflow\") assert snapshot(path(\"${params.outdir}/file1.txt\"), path(\"${params.outdir}/file2.txt\")).match(\"files\") You can also use helper methods to add objects to snapshots. For example, you can use the list() method to add all files of a folder to a snapshot: assert snapshot(workflow, path(params.outdir).list()).match()","title":"More Examples"},{"location":"assertions/snapshots/#file-paths","text":"If nf-test detects a path in the snapshot it automatically replace it by a unique fingerprint of the file that ensures the file content is the same. The fingerprint is default the md5 sum.","title":"File Paths"},{"location":"cli/clean/","text":"clean command Usage nf-test clean The clean command removes the .nf-test directory.","title":"clean"},{"location":"cli/clean/#clean-command","text":"","title":"clean command"},{"location":"cli/clean/#usage","text":"nf-test clean The clean command removes the .nf-test directory.","title":"Usage"},{"location":"cli/generate/","text":"generate command Usage nf-test generate <TEST_CASE_TYPE> <NEXTFLOW_FILES> Supported Types process workflow pipeline function Examples Create a test case for a process: nf-test generate process modules/local/salmon_index.nf Create a test cases for all processes in folder modules : nf-test generate process modules/**/*.nf Create a test case for a sub workflow: nf-test generate workflow workflows/some_workflow.nf Create a test case for the whole pipeline: nf-test generate pipeline main.nf Create a test case for each functio in file functions.nf : nf-test generate function functions.nf","title":"generate"},{"location":"cli/generate/#generate-command","text":"","title":"generate command"},{"location":"cli/generate/#usage","text":"nf-test generate <TEST_CASE_TYPE> <NEXTFLOW_FILES>","title":"Usage"},{"location":"cli/generate/#supported-types","text":"","title":"Supported Types"},{"location":"cli/generate/#process","text":"","title":"process"},{"location":"cli/generate/#workflow","text":"","title":"workflow"},{"location":"cli/generate/#pipeline","text":"","title":"pipeline"},{"location":"cli/generate/#function","text":"","title":"function"},{"location":"cli/generate/#examples","text":"Create a test case for a process: nf-test generate process modules/local/salmon_index.nf Create a test cases for all processes in folder modules : nf-test generate process modules/**/*.nf Create a test case for a sub workflow: nf-test generate workflow workflows/some_workflow.nf Create a test case for the whole pipeline: nf-test generate pipeline main.nf Create a test case for each functio in file functions.nf : nf-test generate function functions.nf","title":"Examples"},{"location":"cli/init/","text":"init command Usage nf-test init The init command set ups nf-test in the current directory. The init command creates the following files: nf-test.config and tests/nextflow.config . It also creates a folder tests which is the home directory of your test code. In the configuration section you can learn more about these files and how to customize the directory layout.","title":"init"},{"location":"cli/init/#init-command","text":"","title":"init command"},{"location":"cli/init/#usage","text":"nf-test init The init command set ups nf-test in the current directory. The init command creates the following files: nf-test.config and tests/nextflow.config . It also creates a folder tests which is the home directory of your test code. In the configuration section you can learn more about these files and how to customize the directory layout.","title":"Usage"},{"location":"cli/test/","text":"test command Usage nf-test test [<NEXTFLOW_FILES>] Optional Arguements --profile <NEXTFLOW_PROFILE> --debug The debug parameter prints out all available output channels which can be accessed in the then clause. --without-trace The Linux tool procps is required to run Nextflow tracing. In case your container does not support this tool, you can also run nf-test without tracing. Please note that the workflow.trace are not available when running it with this flag. --tap <filename> Writes test results in TAP format to file. --junitxml <filename> Writes test results in JUnit XML format to file, which conforms to the standard schema . Examples Run all tests: nf-test test Run all test from a *.test file: nf-test test tests/modules/local/salmon_index.nf.test Run a specific test using its hash: nf-test test tests/main.nf.test@d41119e4 Run all tests and write results to report.tap : nf-test test --tap report.tap","title":"test"},{"location":"cli/test/#test-command","text":"","title":"test command"},{"location":"cli/test/#usage","text":"nf-test test [<NEXTFLOW_FILES>]","title":"Usage"},{"location":"cli/test/#optional-arguements","text":"","title":"Optional Arguements"},{"location":"cli/test/#-profile-nextflow_profile","text":"","title":"--profile &lt;NEXTFLOW_PROFILE&gt;"},{"location":"cli/test/#-debug","text":"The debug parameter prints out all available output channels which can be accessed in the then clause.","title":"--debug"},{"location":"cli/test/#-without-trace","text":"The Linux tool procps is required to run Nextflow tracing. In case your container does not support this tool, you can also run nf-test without tracing. Please note that the workflow.trace are not available when running it with this flag.","title":"--without-trace"},{"location":"cli/test/#-tap-filename","text":"Writes test results in TAP format to file.","title":"--tap &lt;filename&gt;"},{"location":"cli/test/#-junitxml-filename","text":"Writes test results in JUnit XML format to file, which conforms to the standard schema .","title":"--junitxml &lt;filename&gt;"},{"location":"cli/test/#examples","text":"Run all tests: nf-test test Run all test from a *.test file: nf-test test tests/modules/local/salmon_index.nf.test Run a specific test using its hash: nf-test test tests/main.nf.test@d41119e4 Run all tests and write results to report.tap : nf-test test --tap report.tap","title":"Examples"},{"location":"plugins/developing-plugins/","text":"Plugin Development 0.7.0 The following plugin can be used as a boilerplate: https://github.com/askimed/nft-fasta Developing Plugins A plugin has the possibility: Adding a new method to an existing class (e.g. the property fasta to class Path ). It uses Groovy's ExtensionModule concept. Important: the method has to be static. One class can provide multiple methods. // com.askimed.nf.test.fasta.PathExtension public class PathExtension { //can be used as: path(filename).fasta public static Object getFasta ( Path self ) { return FastaUtil . readAsMap ( self ); } } Providing new methods // com.askimed.nf.test.fasta.Methods public class Methods { //can be used as: helloFasta() public static void helloFasta () { System . out . println ( \"Hello FASTA\" ); } } Manifest file You need to create a file META-INF/nf-test-plugin (in your resources). This file contains metadata about the plugin and both classes can now be registered by using the extensionClasses and extensionMethods properties. moduleName=nft-my-plugin moduleVersion=1.0.0 moduleAuthors=Lukas Forer extensionClasses=com.askimed.nf.test.fasta.PathExtension extensionMethods=com.askimed.nf.test.fasta.Methods Building a jar file The plugin itself is a jar file that contains all classes and the META-INF/nf-test-plugin file. If you have dependencies then you have to create a uber-jar that includes all libraries, because nf-test doesn't support the classpath set in META-INF\\MANIFEST . Publishing Plugins Available plugins are managed in this default repository: https://github.com/askimed/nf-test-plugins/blob/main/plugins.json Add your plugin or a new release to the plugin.json file and create a pull request to publish your plugin in the default repository. Or host you own repository: [{ \"id\": \"nft-fasta\", \"releases\": [{ \"version\": \"1.0.0\", \"url\": \"https://github.com/askimed/nft-fasta/releases/download/v1.0.0/nft-fasta-1.0.0.jar\", },{ \"version\": \"2.0.0\", \"url\": \"https://github.com/askimed/nft-fasta/releases/download/v2.0.0/nft-fasta-2.0.0.jar\", }] },{ \"id\": \"nft-my-plugin\", \"releases\": [{ \"version\": \"1.0.0\", \"url\": \"https://github.com/lukfor/nft-my-plugin2/releases/download/v1.0.0/nft-my-plugin-1.0.0.jar\", }] }]","title":"Developing Plugins"},{"location":"plugins/developing-plugins/#plugin-development","text":"0.7.0 The following plugin can be used as a boilerplate: https://github.com/askimed/nft-fasta","title":"Plugin Development"},{"location":"plugins/developing-plugins/#developing-plugins","text":"A plugin has the possibility: Adding a new method to an existing class (e.g. the property fasta to class Path ). It uses Groovy's ExtensionModule concept. Important: the method has to be static. One class can provide multiple methods. // com.askimed.nf.test.fasta.PathExtension public class PathExtension { //can be used as: path(filename).fasta public static Object getFasta ( Path self ) { return FastaUtil . readAsMap ( self ); } } Providing new methods // com.askimed.nf.test.fasta.Methods public class Methods { //can be used as: helloFasta() public static void helloFasta () { System . out . println ( \"Hello FASTA\" ); } }","title":"Developing Plugins"},{"location":"plugins/developing-plugins/#manifest-file","text":"You need to create a file META-INF/nf-test-plugin (in your resources). This file contains metadata about the plugin and both classes can now be registered by using the extensionClasses and extensionMethods properties. moduleName=nft-my-plugin moduleVersion=1.0.0 moduleAuthors=Lukas Forer extensionClasses=com.askimed.nf.test.fasta.PathExtension extensionMethods=com.askimed.nf.test.fasta.Methods","title":"Manifest file"},{"location":"plugins/developing-plugins/#building-a-jar-file","text":"The plugin itself is a jar file that contains all classes and the META-INF/nf-test-plugin file. If you have dependencies then you have to create a uber-jar that includes all libraries, because nf-test doesn't support the classpath set in META-INF\\MANIFEST .","title":"Building a jar file"},{"location":"plugins/developing-plugins/#publishing-plugins","text":"Available plugins are managed in this default repository: https://github.com/askimed/nf-test-plugins/blob/main/plugins.json Add your plugin or a new release to the plugin.json file and create a pull request to publish your plugin in the default repository. Or host you own repository: [{ \"id\": \"nft-fasta\", \"releases\": [{ \"version\": \"1.0.0\", \"url\": \"https://github.com/askimed/nft-fasta/releases/download/v1.0.0/nft-fasta-1.0.0.jar\", },{ \"version\": \"2.0.0\", \"url\": \"https://github.com/askimed/nft-fasta/releases/download/v2.0.0/nft-fasta-2.0.0.jar\", }] },{ \"id\": \"nft-my-plugin\", \"releases\": [{ \"version\": \"1.0.0\", \"url\": \"https://github.com/lukfor/nft-my-plugin2/releases/download/v1.0.0/nft-my-plugin-1.0.0.jar\", }] }]","title":"Publishing Plugins"},{"location":"plugins/using-plugins/","text":"Plugins 0.7.0 Most assertions are usecase specific. Therefore, separating this functionality and helper classes from the nf-test codebase has several advantages: nf-test releases are independent from plugin releases it is easier for third-parties to develop and maintain plugins it is possible to use private repositories to integrate private/protected code in plugins without sharing them For this purpose, we integrated the following plugin system that provides (a) the possibility to extend existing classes with custom methods (e.g. path(filename).fasta ) and (2) to extends nf-test with new methods. Using Plugins Available plugins are listed here . A plugin can be activated via the nf-test.config by adding the plugin section and by using load method to specify the plugin and its version: config { plugins { load \"nft-fasta@1.0.0\" } } It is also possible to add one ore more additional repositories. (Example: repository with development/snapshot versions, in-house repository, ...) config { plugins { repository \"https://github.com/askimed/nf-test-plugins/blob/main/plugins-snapshots.json\" repository \"https://github.com/seppinho/nf-test-plugin2/blob/main/plugins.json\" load \"nft-fasta@1.1.0-snapshot\" load \"nft-plugin2@1.1.0\" // you can also load jar files directly without any repository // loadFromFile \"path/to/my/nft-plugin.jar\" } } All plugins are downloaded and cached in .nf-test\\plugins . This installation mechanism is yet not safe for parallel execution when multiple nf-test instances are resolving the same plugin. However, you can use nf-test update-plugins to download all plugins before you run your tests in parallel. To clear the cache and to force redownloading plugins and repositories you can execute the nf-test clean command. One or multiple plugins can be activated also via the --plugins parameter: nf-test test my-test.nf.test --plugins nft-fasta@1.0.0,plugin2@1.0.0 or nf-test test my-test.nf.test --plugins path/to/my/nft-plugin.jar","title":"Using Plugins"},{"location":"plugins/using-plugins/#plugins","text":"0.7.0 Most assertions are usecase specific. Therefore, separating this functionality and helper classes from the nf-test codebase has several advantages: nf-test releases are independent from plugin releases it is easier for third-parties to develop and maintain plugins it is possible to use private repositories to integrate private/protected code in plugins without sharing them For this purpose, we integrated the following plugin system that provides (a) the possibility to extend existing classes with custom methods (e.g. path(filename).fasta ) and (2) to extends nf-test with new methods.","title":"Plugins"},{"location":"plugins/using-plugins/#using-plugins","text":"Available plugins are listed here . A plugin can be activated via the nf-test.config by adding the plugin section and by using load method to specify the plugin and its version: config { plugins { load \"nft-fasta@1.0.0\" } } It is also possible to add one ore more additional repositories. (Example: repository with development/snapshot versions, in-house repository, ...) config { plugins { repository \"https://github.com/askimed/nf-test-plugins/blob/main/plugins-snapshots.json\" repository \"https://github.com/seppinho/nf-test-plugin2/blob/main/plugins.json\" load \"nft-fasta@1.1.0-snapshot\" load \"nft-plugin2@1.1.0\" // you can also load jar files directly without any repository // loadFromFile \"path/to/my/nft-plugin.jar\" } } All plugins are downloaded and cached in .nf-test\\plugins . This installation mechanism is yet not safe for parallel execution when multiple nf-test instances are resolving the same plugin. However, you can use nf-test update-plugins to download all plugins before you run your tests in parallel. To clear the cache and to force redownloading plugins and repositories you can execute the nf-test clean command. One or multiple plugins can be activated also via the --plugins parameter: nf-test test my-test.nf.test --plugins nft-fasta@1.0.0,plugin2@1.0.0 or nf-test test my-test.nf.test --plugins path/to/my/nft-plugin.jar","title":"Using Plugins"},{"location":"testcases/global_variables/","text":"Global Variables outputDir This variable points to the directory within the temporary test directory ( .nf-test/tests/<test-dir>/output/ ). The variable can be set under params: params { outdir = \"$outputDir\" } baseDir This variable points to the directory to locate the base directory of the main nf-test config. The variable can be used e.g. in the process definition: process { \"\"\" f1 = file('$baseDir/tests/input/file123.gz') \"\"\" }","title":"Global Variables"},{"location":"testcases/global_variables/#global-variables","text":"","title":"Global Variables"},{"location":"testcases/global_variables/#outputdir","text":"This variable points to the directory within the temporary test directory ( .nf-test/tests/<test-dir>/output/ ). The variable can be set under params: params { outdir = \"$outputDir\" }","title":"outputDir"},{"location":"testcases/global_variables/#basedir","text":"This variable points to the directory to locate the base directory of the main nf-test config. The variable can be used e.g. in the process definition: process { \"\"\" f1 = file('$baseDir/tests/input/file123.gz') \"\"\" }","title":"baseDir"},{"location":"testcases/nextflow_function/","text":"Function Testing nf-test allows testing of functions that are defined in a Nextflow file or defined in lib . Please checkout the CLI to generate a function test. Syntax nextflow_function { name \"<NAME>\" script \"<PATH/TO/NEXTFLOW_SCRIPT.nf>\" function \"<FUNCTION_NAME>\" test ( \"<TEST_NAME>\" ) { } } Multiple Functions If a Nextflow script contains multiple functions and you want to test them all in the same testsuite, you can override the function property in each test. For example: functions.nf def function1 () { ... } def function2 () { ... } functions.nf.test nextflow_function { name \"Test functions\" script \"functions.nf\" test ( \"Test function1\" ) { function \"function1\" ... } test ( \"Test function2\" ) { function \"function2\" ... } } Functions in lib folder If you want to test a function that is inside a groovy file in your lib folder, you can ignore the script property, because Nextflow adds them automatically to the classpath. For example: lib\\Utils.groovy class Utils { public static void sayHello(name) { if (name == null) { error('Cannot greet a null person') } def greeting = \"Hello ${name}\" println(greeting) } } tests\\lib\\Utils.groovy.test nextflow_function { name \"Test Utils.groovy\" test ( \"Test function1\" ) { function \"Utils.sayHello\" ... } } Note: the generate function command works only with Nextflow functions. Assertions The function object can be used in asserts to check its status, result value or error messages. // function status assert function . success assert function . failed // return value assert function . result == 27 //returns a list containing all lines from stdout assert function . stdout . contains ( \"Hello World\" ) == 3 Example Nextflow script Create a new file and name it functions.nf . def say_hello ( name ) { if ( name == null ) { error ( 'Cannot greet a null person' ) } def greeting = \"Hello ${name}\" println ( greeting ) return greeting } nf-test script Create a new file and name it functions.nf.test . nextflow_function { name \"Test Function Say Hello\" script \"functions.nf\" function \"say_hello\" test ( \"Passing case\" ) { when { function { \"\"\" input[0] = \"aaron\" \"\"\" } } then { assert function . success assert function . result == \"Hello aaron\" assert function . stdout . contains ( \"Hello aaron\" ) assert function . stderr . isEmpty () } } test ( \"Failure Case\" ) { when { function { \"\"\" input[0] = null \"\"\" } } then { assert function . failed //It seems to me that error(..) writes message to stdout assert function . stdout . contains ( \"Cannot greet a null person\" ) } } } Execute test nf-test test functions.nf.test","title":"Function Testing"},{"location":"testcases/nextflow_function/#function-testing","text":"nf-test allows testing of functions that are defined in a Nextflow file or defined in lib . Please checkout the CLI to generate a function test.","title":"Function Testing"},{"location":"testcases/nextflow_function/#syntax","text":"nextflow_function { name \"<NAME>\" script \"<PATH/TO/NEXTFLOW_SCRIPT.nf>\" function \"<FUNCTION_NAME>\" test ( \"<TEST_NAME>\" ) { } }","title":"Syntax"},{"location":"testcases/nextflow_function/#multiple-functions","text":"If a Nextflow script contains multiple functions and you want to test them all in the same testsuite, you can override the function property in each test. For example:","title":"Multiple Functions"},{"location":"testcases/nextflow_function/#functionsnf","text":"def function1 () { ... } def function2 () { ... }","title":"functions.nf"},{"location":"testcases/nextflow_function/#functionsnftest","text":"nextflow_function { name \"Test functions\" script \"functions.nf\" test ( \"Test function1\" ) { function \"function1\" ... } test ( \"Test function2\" ) { function \"function2\" ... } }","title":"functions.nf.test"},{"location":"testcases/nextflow_function/#functions-in-lib-folder","text":"If you want to test a function that is inside a groovy file in your lib folder, you can ignore the script property, because Nextflow adds them automatically to the classpath. For example:","title":"Functions in lib folder"},{"location":"testcases/nextflow_function/#libutilsgroovy","text":"class Utils { public static void sayHello(name) { if (name == null) { error('Cannot greet a null person') } def greeting = \"Hello ${name}\" println(greeting) } }","title":"lib\\Utils.groovy"},{"location":"testcases/nextflow_function/#testslibutilsgroovytest","text":"nextflow_function { name \"Test Utils.groovy\" test ( \"Test function1\" ) { function \"Utils.sayHello\" ... } } Note: the generate function command works only with Nextflow functions.","title":"tests\\lib\\Utils.groovy.test"},{"location":"testcases/nextflow_function/#assertions","text":"The function object can be used in asserts to check its status, result value or error messages. // function status assert function . success assert function . failed // return value assert function . result == 27 //returns a list containing all lines from stdout assert function . stdout . contains ( \"Hello World\" ) == 3","title":"Assertions"},{"location":"testcases/nextflow_function/#example","text":"","title":"Example"},{"location":"testcases/nextflow_function/#nextflow-script","text":"Create a new file and name it functions.nf . def say_hello ( name ) { if ( name == null ) { error ( 'Cannot greet a null person' ) } def greeting = \"Hello ${name}\" println ( greeting ) return greeting }","title":"Nextflow script"},{"location":"testcases/nextflow_function/#nf-test-script","text":"Create a new file and name it functions.nf.test . nextflow_function { name \"Test Function Say Hello\" script \"functions.nf\" function \"say_hello\" test ( \"Passing case\" ) { when { function { \"\"\" input[0] = \"aaron\" \"\"\" } } then { assert function . success assert function . result == \"Hello aaron\" assert function . stdout . contains ( \"Hello aaron\" ) assert function . stderr . isEmpty () } } test ( \"Failure Case\" ) { when { function { \"\"\" input[0] = null \"\"\" } } then { assert function . failed //It seems to me that error(..) writes message to stdout assert function . stdout . contains ( \"Cannot greet a null person\" ) } } }","title":"nf-test script"},{"location":"testcases/nextflow_function/#execute-test","text":"nf-test test functions.nf.test","title":"Execute test"},{"location":"testcases/nextflow_pipeline/","text":"Pipeline Testing nf-test also allows to test the complete pipeline end-to-end. Please checkout the CLI to generate a pipeline test. Syntax nextflow_pipeline { name \"<NAME>\" script \"<PATH/TO/NEXTFLOW_SCRIPT.nf>\" test ( \"<TEST_NAME>\" ) { } } Assertions The workflow object can be used in asserts to check its status, error messages or traces. // workflow status assert workflow . success assert workflow . failed assert workflow . exitStatus == 0 // workflow error message assert workflow . errorReport . contains ( \"....\" ) // trace //returns a list containing succeeded tasks assert workflow . trace . succeeded (). size () == 3 //returns a list containing failed tasks assert workflow . trace . failed (). size () == 0 //returns a list containing all tasks assert workflow . trace . tasks (). size () == 3 Example Nextflow script Create a new file and name it pipeline.nf . #!/usr/bin/env nextflow nextflow . enable . dsl = 2 process SAY_HELLO { input: val cheers output: stdout emit: verbiage_ch path '*.txt' , emit: verbiage_ch2 script: \"\"\" echo -n $cheers echo -n $cheers > ${cheers}.txt \"\"\" } workflow { input = params . input_text . trim (). split ( ',' ) Channel . from ( input ) | SAY_HELLO } nf-test script Create a new file and name it pipeline.nf.test . nextflow_pipeline { name \"Test Pipeline with 1 process\" script \"pipeline.nf\" test ( \"Should run without failures\" ) { when { params { input_text = \"hello,nf-test\" } } then { assert workflow . success assert workflow . trace . tasks (). size () == 2 } } } Execute test nf-test init nf-test test pipeline.nf.test","title":"Pipeline Testing"},{"location":"testcases/nextflow_pipeline/#pipeline-testing","text":"nf-test also allows to test the complete pipeline end-to-end. Please checkout the CLI to generate a pipeline test.","title":"Pipeline Testing"},{"location":"testcases/nextflow_pipeline/#syntax","text":"nextflow_pipeline { name \"<NAME>\" script \"<PATH/TO/NEXTFLOW_SCRIPT.nf>\" test ( \"<TEST_NAME>\" ) { } }","title":"Syntax"},{"location":"testcases/nextflow_pipeline/#assertions","text":"The workflow object can be used in asserts to check its status, error messages or traces. // workflow status assert workflow . success assert workflow . failed assert workflow . exitStatus == 0 // workflow error message assert workflow . errorReport . contains ( \"....\" ) // trace //returns a list containing succeeded tasks assert workflow . trace . succeeded (). size () == 3 //returns a list containing failed tasks assert workflow . trace . failed (). size () == 0 //returns a list containing all tasks assert workflow . trace . tasks (). size () == 3","title":"Assertions"},{"location":"testcases/nextflow_pipeline/#example","text":"","title":"Example"},{"location":"testcases/nextflow_pipeline/#nextflow-script","text":"Create a new file and name it pipeline.nf . #!/usr/bin/env nextflow nextflow . enable . dsl = 2 process SAY_HELLO { input: val cheers output: stdout emit: verbiage_ch path '*.txt' , emit: verbiage_ch2 script: \"\"\" echo -n $cheers echo -n $cheers > ${cheers}.txt \"\"\" } workflow { input = params . input_text . trim (). split ( ',' ) Channel . from ( input ) | SAY_HELLO }","title":"Nextflow script"},{"location":"testcases/nextflow_pipeline/#nf-test-script","text":"Create a new file and name it pipeline.nf.test . nextflow_pipeline { name \"Test Pipeline with 1 process\" script \"pipeline.nf\" test ( \"Should run without failures\" ) { when { params { input_text = \"hello,nf-test\" } } then { assert workflow . success assert workflow . trace . tasks (). size () == 2 } } }","title":"nf-test script"},{"location":"testcases/nextflow_pipeline/#execute-test","text":"nf-test init nf-test test pipeline.nf.test","title":"Execute test"},{"location":"testcases/nextflow_process/","text":"Process Testing nf-test allows to test each process defined in a module file. Please checkout the CLI to generate a process test. Syntax nextflow_process { name \"<NAME>\" script \"<PATH/TO/NEXTFLOW_SCRIPT.nf>\" process \"<PROCESS_NAME>\" test ( \"<TEST_NAME>\" ) { } } Assertions The process object can be used in asserts to check its status or error messages. // process status assert process . success assert process . failed assert process . exitStatus == 0 // Analyze Nextflow trace file assert process . trace . tasks (). size () == 1 // process error message assert process . errorReport . contains ( \"....\" ) //returns a list containing all lines from stdout assert process . stdout . contains ( \"Hello World\" ) == 3 Output Channels The process.out object provides access to the content of all named output Channels (see Nextflow emit ): // channel exists assert process . out . my_channel != null // channel contains 3 elements assert process . out . my_channel . size () == 3 // first element is \"hello\" assert process . out . my_channel . get ( 0 ) == \"hello\" Example Nextflow script Create a new file and name it say_hello.nf . #!/usr/bin/env nextflow nextflow . enable . dsl = 2 process SAY_HELLO { input: val cheers output: stdout emit: verbiage_ch path '*.txt' , emit: verbiage_ch2 script: \"\"\" echo -n $cheers echo -n $cheers > ${cheers}.txt \"\"\" } nf-test script Create a new file and name it say_hello.nf.test . nextflow_process { name \"Test Process SAY_HELLO\" script \"say_hello.nf\" process \"SAY_HELLO\" test ( \"Should run without failures\" ) { when { process { \"\"\" input[0] = Channel.from('hello','nf-test') \"\"\" } } then { assert process . success assert process . trace . tasks (). size () == 2 with ( process . out . trial_out_ch ) { assert size () == 2 assert path ( get ( 0 )). readLines (). size () == 1 assert path ( get ( 1 )). readLines (). size () == 1 assert path ( get ( 1 )). md5 == \"4a17df7a54b41a84df492da3f1bab1e3\" } } } } Execute test nf-test init nf-test test say_hello.nf.test","title":"Process Testing"},{"location":"testcases/nextflow_process/#process-testing","text":"nf-test allows to test each process defined in a module file. Please checkout the CLI to generate a process test.","title":"Process Testing"},{"location":"testcases/nextflow_process/#syntax","text":"nextflow_process { name \"<NAME>\" script \"<PATH/TO/NEXTFLOW_SCRIPT.nf>\" process \"<PROCESS_NAME>\" test ( \"<TEST_NAME>\" ) { } }","title":"Syntax"},{"location":"testcases/nextflow_process/#assertions","text":"The process object can be used in asserts to check its status or error messages. // process status assert process . success assert process . failed assert process . exitStatus == 0 // Analyze Nextflow trace file assert process . trace . tasks (). size () == 1 // process error message assert process . errorReport . contains ( \"....\" ) //returns a list containing all lines from stdout assert process . stdout . contains ( \"Hello World\" ) == 3","title":"Assertions"},{"location":"testcases/nextflow_process/#output-channels","text":"The process.out object provides access to the content of all named output Channels (see Nextflow emit ): // channel exists assert process . out . my_channel != null // channel contains 3 elements assert process . out . my_channel . size () == 3 // first element is \"hello\" assert process . out . my_channel . get ( 0 ) == \"hello\"","title":"Output Channels"},{"location":"testcases/nextflow_process/#example","text":"","title":"Example"},{"location":"testcases/nextflow_process/#nextflow-script","text":"Create a new file and name it say_hello.nf . #!/usr/bin/env nextflow nextflow . enable . dsl = 2 process SAY_HELLO { input: val cheers output: stdout emit: verbiage_ch path '*.txt' , emit: verbiage_ch2 script: \"\"\" echo -n $cheers echo -n $cheers > ${cheers}.txt \"\"\" }","title":"Nextflow script"},{"location":"testcases/nextflow_process/#nf-test-script","text":"Create a new file and name it say_hello.nf.test . nextflow_process { name \"Test Process SAY_HELLO\" script \"say_hello.nf\" process \"SAY_HELLO\" test ( \"Should run without failures\" ) { when { process { \"\"\" input[0] = Channel.from('hello','nf-test') \"\"\" } } then { assert process . success assert process . trace . tasks (). size () == 2 with ( process . out . trial_out_ch ) { assert size () == 2 assert path ( get ( 0 )). readLines (). size () == 1 assert path ( get ( 1 )). readLines (). size () == 1 assert path ( get ( 1 )). md5 == \"4a17df7a54b41a84df492da3f1bab1e3\" } } } }","title":"nf-test script"},{"location":"testcases/nextflow_process/#execute-test","text":"nf-test init nf-test test say_hello.nf.test","title":"Execute test"},{"location":"testcases/nextflow_workflow/","text":"Workflow Testing nf-test also allows to test a specific workflow. Please checkout the CLI to generate a workflow test. Syntax nextflow_workflow { name \"<NAME>\" script \"<PATH/TO/NEXTFLOW_SCRIPT.nf>\" workflow \"<WORKFLOW_NAME>\" test ( \"<TEST_NAME>\" ) { } } Assertions The workflow object can be used in asserts to check its status, error messages or traces. // workflow status assert workflow . success assert workflow . failed assert workflow . exitStatus == 0 // workflow error message assert workflow . errorReport . contains ( \"....\" ) // trace //returns a list containing succeeded tasks assert workflow . trace . succeeded (). size () == 3 //returns a list containing failed tasks assert workflow . trace . failed (). size () == 0 //returns a list containing all tasks assert workflow . trace . tasks (). size () == 3 //returns a list containing all lines from stdout assert workflow . stdout . contains ( \"Hello World\" ) == 3 Example Nextflow script Create a new file and name it trial.nf . #!/usr/bin/env nextflow nextflow . enable . dsl = 2 process sayHello { input: val cheers output: stdout emit: verbiage_ch path '*.txt' , emit: verbiage_ch2 script: \"\"\" echo -n $cheers echo -n $cheers > ${cheers}.txt \"\"\" } workflow trial { take: things main: sayHello ( things ) sayHello . out . verbiage_ch . view () emit: trial_out_ch = sayHello . out . verbiage_ch2 } workflow { Channel . from ( 'hello' , 'nf-test' ) | trial } nf-test script Create a new file and name it trial.nf.test . nextflow_workflow { name \"Test Workflow Trial\" script \"trial.nf\" workflow \"trial\" test ( \"Should run without failures\" ) { when { workflow { \"\"\" input[0] = Channel.from('hello','nf-test') \"\"\" } } then { assert workflow . success with ( workflow . out . trial_out_ch ) { assert size () == 2 assert path ( get ( 0 )). readLines (). size () == 1 assert path ( get ( 1 )). readLines (). size () == 1 assert path ( get ( 1 )). md5 == \"4a17df7a54b41a84df492da3f1bab1e3\" } } } } Execute test nf-test init nf-test test trial.nf.test","title":"Workflow Testing"},{"location":"testcases/nextflow_workflow/#workflow-testing","text":"nf-test also allows to test a specific workflow. Please checkout the CLI to generate a workflow test.","title":"Workflow Testing"},{"location":"testcases/nextflow_workflow/#syntax","text":"nextflow_workflow { name \"<NAME>\" script \"<PATH/TO/NEXTFLOW_SCRIPT.nf>\" workflow \"<WORKFLOW_NAME>\" test ( \"<TEST_NAME>\" ) { } }","title":"Syntax"},{"location":"testcases/nextflow_workflow/#assertions","text":"The workflow object can be used in asserts to check its status, error messages or traces. // workflow status assert workflow . success assert workflow . failed assert workflow . exitStatus == 0 // workflow error message assert workflow . errorReport . contains ( \"....\" ) // trace //returns a list containing succeeded tasks assert workflow . trace . succeeded (). size () == 3 //returns a list containing failed tasks assert workflow . trace . failed (). size () == 0 //returns a list containing all tasks assert workflow . trace . tasks (). size () == 3 //returns a list containing all lines from stdout assert workflow . stdout . contains ( \"Hello World\" ) == 3","title":"Assertions"},{"location":"testcases/nextflow_workflow/#example","text":"","title":"Example"},{"location":"testcases/nextflow_workflow/#nextflow-script","text":"Create a new file and name it trial.nf . #!/usr/bin/env nextflow nextflow . enable . dsl = 2 process sayHello { input: val cheers output: stdout emit: verbiage_ch path '*.txt' , emit: verbiage_ch2 script: \"\"\" echo -n $cheers echo -n $cheers > ${cheers}.txt \"\"\" } workflow trial { take: things main: sayHello ( things ) sayHello . out . verbiage_ch . view () emit: trial_out_ch = sayHello . out . verbiage_ch2 } workflow { Channel . from ( 'hello' , 'nf-test' ) | trial }","title":"Nextflow script"},{"location":"testcases/nextflow_workflow/#nf-test-script","text":"Create a new file and name it trial.nf.test . nextflow_workflow { name \"Test Workflow Trial\" script \"trial.nf\" workflow \"trial\" test ( \"Should run without failures\" ) { when { workflow { \"\"\" input[0] = Channel.from('hello','nf-test') \"\"\" } } then { assert workflow . success with ( workflow . out . trial_out_ch ) { assert size () == 2 assert path ( get ( 0 )). readLines (). size () == 1 assert path ( get ( 1 )). readLines (). size () == 1 assert path ( get ( 1 )). md5 == \"4a17df7a54b41a84df492da3f1bab1e3\" } } } }","title":"nf-test script"},{"location":"testcases/nextflow_workflow/#execute-test","text":"nf-test init nf-test test trial.nf.test","title":"Execute test"}]}